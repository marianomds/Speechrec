/**
	* @brief
	* @param
	* @param
	*/
void ProcessAudio (void const *pvParameters) {
	osEvent event;
	FIL WaveFile;
	FIL MFCCFile, HamWinFile, CepWeiFile, SpeechFile, FltSigFile, WinSigFile, FFTWinFile, MagFFTFile, MelWinFile, LogWinFile, CepWinFile;
	static uint16_t data[FRAME_LEN];
	UINT bytesread, byteswritten;
	static float32_t MFCC[LIFTER_LEGNTH];
	uint32_t audiosize;
	FIL nada;
	
	/* START TASK */
	for(;;) {
		
		event = osMessageGet(ProcessFile,osWaitForever);
		if(event.status == osEventMessage) {
					
			// Escribo un archivo con los coeficientes de la ventana de Hamming
			if(f_open(&HamWinFile, "HamWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_write(&HamWinFile, HamWin, FRAME_LEN*4, &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
			f_close(&HamWinFile);			
			
			// Escribo un archivo con los coeficientes del Filtro Cepstral
			if(f_open(&CepWeiFile, "CepWei.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_write(&CepWeiFile, CepWeight, LIFTER_LEGNTH*4, &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
			f_close(&CepWeiFile);

			//Abro los archivos
			if(f_open(&SpeechFile, "Speech.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&FltSigFile, "FltSig.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&WinSigFile, "WinSig.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&FFTWinFile, "FFTWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&MagFFTFile, "MagFFT.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&MelWinFile, "MelWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&LogWinFile, "LogWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&CepWinFile, "CepWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			if(f_open(&MFCCFile, 	 "MelFCC.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
			
			if(f_open(&nada, 	 "nada.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();

			//Abro el archivo de audio
			if(f_open(&WaveFile,event.value.p,FA_READ) != FR_OK)
				Error_Handler();
			
			//Voy a la parte donde me indica el tamaño del audio
			if(f_lseek(&WaveFile,40) != FR_OK)
				Error_Handler();
			
			//Leo el tamaño del audio (almacenado en 4 bytes) y queda listo para leer el audio
				if(f_read (&WaveFile, &audiosize, 4, &bytesread) != FR_OK)
					Error_Handler();
				audiosize /= 2;	//lo divido por dos porque viene en cantidad de bytes
			
			/************************************************************************************************************************
						NOTA: EN VEZ DE LEER TODO UN FRAME DEVUELTA ME CONVIENE HACER UNA COLA CIRCULAR DONDE VOY DESPLAZANDO LOS DATOS
			***************************************************************************************************************************/
			
			/* Proceso todos los datos hasta leer todo el archivo */
			do {
				//Leo parte del archivo
				if(f_read (&WaveFile, data, FRAME_LEN*2, &bytesread) != FR_OK)		//Multiplico por 2 porque tengo que pasarle la cantidad en bytes
					Error_Handler();
				
				//Si estoy en el último Frame relleno el final del Frame con ceros
				if(audiosize < FRAME_LEN)
					arm_fill_q15 (0,(q15_t *) &data[audiosize], FRAME_LEN-audiosize);
				
				//Obtengo los MFCC
				MFCC_float (MFCC, data, HamWin, CepWeight);
				
				//Escribo los valores intermedios en un archivo
				if(f_write(&SpeechFile, speech, FRAME_LEN*4,   &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&FltSigFile, FltSig, FRAME_LEN*4,   &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
//				if(f_write(&WinSigFile, WinSig, FRAME_LEN*4,   &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&WinSigFile, AUX, FRAME_LEN*4,   &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&FFTWinFile, FFTWin, FFT_LEN*4,     &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&MagFFTFile, MagFFT, FFT_LEN/2*4,   &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&MelWinFile, MelWin, MEL_BANKS*4,      &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&LogWinFile, LogWin, IFFT_LEN*4,      &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&CepWinFile, CepWin, IFFT_LEN*4,     &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
//				if(f_write(&MFCCFile,     MFCC, LIFTER_LEGNTH*4,  &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
				if(f_write(&MFCCFile,     AUX2, LIFTER_LEGNTH*4,  &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes				
				
				if(f_write(&nada, aux, 1,  &byteswritten) != FR_OK)	Error_Handler();
				
				//Vuelvo atras en el archivo por el overlap que hay en las señales
				if(f_lseek(&WaveFile,f_tell(&WaveFile)-FRAME_OVERLAP*2) != FR_OK)
					Error_Handler();
				
				//Actualizo lo que me queda por leer
				audiosize -= FRAME_NET;
				
			} while(bytesread >= FRAME_LEN*2);	//Como los datos leidos son menores ==> EOF
			
			f_close(&WaveFile);
			f_close(&SpeechFile);
			f_close(&FltSigFile);
			f_close(&WinSigFile);
			f_close(&FFTWinFile);
			f_close(&MagFFTFile);
			f_close(&MelWinFile);
			f_close(&LogWinFile);
			f_close(&CepWinFile);
			f_close(&MFCCFile);
			
			f_close(&nada);
			
			LED_On(BLED);
		}
	}
}

/**
  * @brief  Obtains the Mel-Frequency Cepstrum Coefficients
	* @param  SpeechFrame: Address of the vector with the Speech signal of the Frame to be processed
	* @param  SigSize: Length of the Frame
	* @param  HamWin: Address of the vector with the Window to apply
	* @param  Lifter: Address of the vector of the Lifter Coefficents to apply
	* @param  alpha: Coefficient of the Pre-emphasis Filter
	* @param  CoefNum: 
	* @param  L: 
  * @retval 
  */
void MFCC_float (float32_t *MFCC, uint16_t *Frame, float32_t *HamWin, float32_t *Lifter) {

	arm_fir_instance_f32 FirInst;
	float32_t Pre_enfasis_Coeef[NUMTAPS]={-ALPHA,1};
	float32_t pState[NUMTAPS+FRAME_LEN-1];	
	
	arm_matrix_instance_f32 MagFFTMtx;
	arm_matrix_instance_f32 MelWinMtx= {MEL_BANKS, 1, MelWin};
	
	arm_rfft_fast_instance_f32 RFFTinst, DCTinst;

	arm_status status;
	int i;

	//Convierto a Float y escalo
	arm_q15_to_float((q15_t*)Frame, speech, FRAME_LEN);
	
	/* Se aplica un filtro de Pre-énfais al segmento de señal obtenida */	
	arm_fir_init_f32 (&FirInst, NUMTAPS, Pre_enfasis_Coeef, pState, FRAME_LEN);
	arm_fir_f32 (&FirInst, speech, FltSig, FRAME_LEN);
	
	/* Se le aplica la ventana de Hamming al segmento obtenido */
	arm_mult_f32 (FltSig, HamWin, WinSig, FRAME_LEN);
	arm_copy_f32 (WinSig,AUX,FRAME_LEN);	//LO COPIO SOLO PARA COMPARAR PORQUE LA RFFT ME CAMBIA EL VALOR
	
// REVISAR LO DE ABAJO, NO SE SI ESTA BIEN
//	/* Hago Zero-Padding si es necesario */
//	if(FFT_LEN != FRAME_LEN){
//		//Relleno con ceros en la parte izquierda
//		arm_fill_f32 	(0,FFTWin,(FFT_LEN-FRAME_LEN)/2);
//		//Relleno con ceros en la parte derecha
//		arm_fill_f32 	(0,&FFTWin[(FFT_LEN+FRAME_LEN)/2],(FFT_LEN-FRAME_LEN)/2);
//	}
	
	/* Se calcula la DFT */
	status = arm_rfft_fast_init_f32 (&RFFTinst, FFT_LEN);
	if(status == ARM_MATH_ARGUMENT_ERROR)
		Error();
	arm_rfft_fast_f32(&RFFTinst,WinSig,FFTWin,0);	// Se calcula la FFT		
	FFTWin[1]=0;		//Borro la componente de máxima frec
	
	/* Calculo el módulo de la FFT */
	arm_cmplx_mag_squared_f32  (FFTWin, MagFFT, FFT_LEN/2);			// Se calcula el módulo de la FFT
		
	/* Se pasa el espectro por los filtros del banco de Mel y se obtienen los coeficientes */
	arm_mat_init_f32 (&MagFFTMtx, FFT_LEN/2, 1, MagFFT);						// Se convierte la FFT a una Matriz de filas=fftLen y columnas=1
	status = arm_mat_mult_f32(&MelFilt, &MagFFTMtx, &MelWinMtx);		// MelFilt[MEL_BANKS,FFT_LEN] * MagFFTMtx[FFT_LEN,1] = MelWinMtx [MEL_BANKS,1]	
	if(status == ARM_MATH_SIZE_MISMATCH)
		Error();

	/* Se obtienen los valores logaritmicos de los coeficientes y le hago zero-padding */
	arm_fill_f32 	(0,LogWin,IFFT_LEN);
	for (i=0; i<MEL_BANKS; i++)
		LogWin[i*2+2] = log10(MelWin[i]);

	
	/* Se Anti-transforma aplicando la DCT-II ==> hago la anti-transformada real */
	status = arm_rfft_fast_init_f32 (&DCTinst, IFFT_LEN);
	if(status == ARM_MATH_ARGUMENT_ERROR)
		Error();
	arm_rfft_fast_f32(&DCTinst,LogWin,CepWin,1);
	
	/* Se pasa la señal por un filtro en el campo Cepstral */
//	arm_mult_f32 (CepWin,Lifter,MFCC,LIFTER_LEGNTH);
	arm_mult_f32 (CepWin,Lifter,AUX2,LIFTER_LEGNTH);
}



/**
	* @brief
	* @param
	* @param
	*/
void ProcessTest (void const *pvParameters) {

	UINT byteswritten;
	FIL Sig, fftTest, IfftTest;
	int i;
	arm_rfft_fast_instance_f32 RFFTinst, DCTinst;
	arm_status status;
	
	/* START TASK */
	for(;;) {
		
		if(f_open(&Sig, 		 "Sig.bin",   FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
		if(f_open(&fftTest,  "fft.bin",   FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();
		if(f_open(&IfftTest, "ifft.bin",  FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();

		
		for(i=0;i<512;i++)
			signal[i] = arm_cos_f32 (2*PI*3125*i/16000);
		
		/* Se calcula la DFT */
		arm_copy_f32 (signal,aux,FFT_LEN);	//LO COPIO SOLO PARA COMPARAR PORQUE LA RFFT ME CAMBIA EL VALOR
		status = arm_rfft_fast_init_f32 (&RFFTinst, FFT_LEN);
		if(status == ARM_MATH_ARGUMENT_ERROR)
			Error();
		arm_rfft_fast_f32(&RFFTinst,aux,fft,0);	// Se calcula la FFT
		
		
		// CON RIFFT
		arm_copy_f32 (fft,aux,FFT_LEN);	//LO COPIO SOLO PARA COMPARAR PORQUE LA RFFT ME CAMBIA EL VALOR
		status = arm_rfft_fast_init_f32 (&DCTinst, FFT_LEN);
		if(status == ARM_MATH_ARGUMENT_ERROR)
			Error();
		arm_rfft_fast_f32(&DCTinst,aux,ifft,1);

		// CON CIFFT
//	const static arm_cfft_instance_f32 *S;
//	S = &arm_cfft_sR_f32_len512;
//	
//	// Copio la primera parte del espectro
//	arm_copy_f32 	(FFTWin,Test,FFT_LEN);
//	// Copio la senguda parte(espejo)
//	for(i=1;i<FFT_LEN/2;i++) {
//		Test[FFT_LEN+i*2] = FFTWin[FFT_LEN-i*2];	// Parte Real
//		Test[FFT_LEN+1+i*2] = FFTWin[FFT_LEN+1-i*2];	// Parte Imaginaria
//	}
//	Test[FFT_LEN] = FFTWin[1];	//Copio el Valor FFTWin[fftlen/2] que es real
//	Test[FFT_LEN+1] = 0;				//La parte imaginaria 0
//	Test[1] = 0;								//La parte imaginaria 0
//	
//	//Calculo la IFFT
//	arm_cfft_f32 	(S, Test,1,1); 
//	//Escalo porque la IFFT hace 1/fftlen
//	arm_scale_f32 (Test, FFT_LEN, Test, FFT_LEN);
//	//Calculo el error
//	arm_sub_f32 (WinSig, Test, Test2, FFT_LEN);


		if(f_write(&Sig,signal, FFT_LEN*4,  &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
		if(f_write(&fftTest,fft, FFT_LEN*4,  &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
		if(f_write(&IfftTest,ifft, FFT_LEN*4,  &byteswritten) != FR_OK)	Error_Handler();//Multiplico por 4 porque tengo que pasarle la cantidad en bytes
			
		f_close(&Sig);
		f_close(&fftTest);
		f_close(&IfftTest);
		
		LED_On(BLED);
		
		osThreadTerminate(osThreadGetId ());
	}
}
