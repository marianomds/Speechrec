/**
  ******************************************************************************
  * @file    audio_processing.c
  * @author  Alejandro Alvarez
  * @version V1.0.0
  * @date    28-Enero-2014
  * @brief   Audio Functions for ASR_DTW
  ******************************************************************************
  * @attention
  *
  ******************************************************************************
	*/

/* Includes ------------------------------------------------------------------*/
#include <audio_processing.h>
#include <misc.h>
#include <error_handler.h>
#include <ale_dct2_f32.h>
//#include <Application.h>
#include <ApplicationConfig.h>

//---------------------------------------
//				MESSAGE QUEUE VARIALBES
//---------------------------------------

static osMessageQId proc_msg;
static osMessageQId calib_msg;

//---------------------------------------
//				CONFIGURATION VARIALBES
//---------------------------------------

static Proc_conf	*proc_conf;						// Processing configurartion

//---------------------------------------
//				SPEECH PROCESSING VARIALBES
//---------------------------------------
__align(8)

static float32_t *pState = NULL;							// [proc_conf->numtaps + proc_conf->frame_net - 1]
static float32_t *Pre_enfasis_Coeef = NULL;	// [proc_conf->numtaps]

static float32_t *aux1 = NULL; 							// [ max(proc_conf->frame_len,proc_conf->fft_len) ];
static float32_t *aux2 = NULL; 							// [ max(proc_conf->frame_len,proc_conf->fft_len) ];
	
static float32_t *HamWin = NULL; 						// [proc_conf->frame_len];
static float32_t *CepWeight = NULL; 					// [LIFTER_length];

//TODO Obtener los valores programáticamente (buscar )
static float32_t MelBanks [FFT_LEN/2*MEL_BANKS] = {
0,4.7763270e-001f,8.3185238e-001f,1.7230715e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1.6814762e-001f,8.2769285e-001f,5.4164890e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4.5835110e-001f,9.2587772e-001f,3.4221939e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,7.4122278e-002f,6.5778061e-001f,7.7287531e-001f,2.2382045e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,2.2712469e-001f,7.7617955e-001f,6.9404783e-001f,1.7754490e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3.0595217e-001f,8.2245510e-001f,6.8113785e-001f,1.9525693e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,3.1886215e-001f,8.0474307e-001f,7.2660630e-001f,2.6953191e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,2.7339370e-001f,7.3046809e-001f,8.2357639e-001f,3.9360066e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.7642361e-001f,6.0639934e-001f,9.6578150e-001f,5.6129783e-001f,1.5681416e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.4218496e-002f,4.3870217e-001f,8.4318584e-001f,7.6701413e-001f,3.8651116e-001f,6.0081975e-003f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.3298587e-001f,6.1348884e-001f,9.9399180e-001f,6.4770798e-001f,2.8976397e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.5229202e-001f,7.1023603e-001f,9.3586217e-001f,5.9913966e-001f,2.6241716e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.4137829e-002f,4.0086034e-001f,7.3758284e-001f,9.3010001e-001f,6.1334083e-001f,2.9658166e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.9899994e-002f,3.8665917e-001f,7.0341834e-001f,9.8101876e-001f,6.8303936e-001f,3.8505995e-001f,8.7080545e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.8981239e-002f,3.1696064e-001f,6.1494005e-001f,9.1291945e-001f,8.0160474e-001f,5.2129171e-001f,2.4097867e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.9839526e-001f,4.7870829e-001f,7.5902133e-001f,9.6299765e-001f,6.9930359e-001f,4.3560953e-001f,1.7191546e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.7002348e-002f,3.0069641e-001f,5.6439047e-001f,8.2808454e-001f,9.1366270e-001f,6.6560232e-001f,4.1754194e-001f,1.6948156e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8.6337302e-002f,3.3439768e-001f,5.8245806e-001f,8.3051844e-001f,9.2607990e-001f,6.9272633e-001f,4.5937276e-001f,2.2601919e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7.3920098e-002f,3.0727367e-001f,5.4062724e-001f,7.7398081e-001f,9.9310045e-001f,7.7358176e-001f,5.5406307e-001f,3.3454438e-001f,1.1502569e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.8995507e-003f,2.2641824e-001f,4.4593693e-001f,6.6545562e-001f,8.8497431e-001f,9.0170209e-001f,6.9519805e-001f,4.8869401e-001f,2.8218997e-001f,7.5685927e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9.8297908e-002f,3.0480195e-001f,5.1130599e-001f,7.1781003e-001f,9.2431407e-001f,8.7693773e-001f,6.8267673e-001f,4.8841574e-001f,2.9415474e-001f,9.9893749e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.2306227e-001f,3.1732327e-001f,5.1158426e-001f,7.0584526e-001f,9.0010625e-001f,9.1122753e-001f,7.2848372e-001f,5.4573992e-001f,3.6299612e-001f,1.8025231e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8.8772475e-002f,2.7151628e-001f,4.5426008e-001f,6.3700388e-001f,8.1974769e-001f,9.9765623e-001f,8.2574679e-001f,6.5383736e-001f,4.8192793e-001f,3.1001849e-001f,1.3810906e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.3437745e-003f,1.7425321e-001f,3.4616264e-001f,5.1807207e-001f,6.8998151e-001f,8.6189094e-001f,9.6820355e-001f,8.0648615e-001f,6.4476875e-001f,4.8305134e-001f,3.2133394e-001f,1.5961654e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.1796445e-002f,1.9351385e-001f,3.5523125e-001f,5.1694866e-001f,6.7866606e-001f,8.4038346e-001f,9.9802369e-001f,8.4589406e-001f,6.9376443e-001f,5.4163480e-001f,3.8950516e-001f,2.3737553e-001f,8.5245903e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.9763123e-003f,1.5410594e-001f,3.0623557e-001f,4.5836520e-001f,6.1049484e-001f,7.6262447e-001f,9.1475410e-001f,9.3708162e-001f,7.9397133e-001f,6.5086104e-001f,5.0775075e-001f,3.6464046e-001f,2.2153017e-001f,7.8419881e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.2918378e-002f,2.0602867e-001f,3.4913896e-001f,4.9224925e-001f,6.3535954e-001f,7.7846983e-001f,9.2158012e-001f,9.3914490e-001f,8.0451922e-001f,6.6989354e-001f,5.3526786e-001f,4.0064218e-001f,2.6601650e-001f,1.3139082e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.0855096e-002f,1.9548078e-001f,3.3010646e-001f,4.6473214e-001f,5.9935782e-001f,7.3398350e-001f,8.6860918e-001f,9.9695692e-001f,8.7031282e-001f,7.4366872e-001f,6.1702462e-001f,4.9038052e-001f,3.6373642e-001f,2.3709232e-001f,1.1044822e-001f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.0430775e-003f,1.2968718e-001f,2.5633128e-001f,3.8297538e-001f,5.0961948e-001f,6.3626358e-001f,7.6290768e-001f,8.8955178e-001f,9.8476433e-001f,8.6562860e-001f,7.4649287e-001f,6.2735715e-001f,5.0822142e-001f,3.8908570e-001f,2.6994997e-001f,1.5081424e-001f,3.1678517e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.5235675e-002f,1.3437140e-001f,2.5350713e-001f,3.7264285e-001f,4.9177858e-001f,6.1091430e-001f,7.3005003e-001f,8.4918576e-001f,9.6832148e-001f,9.1772788e-001f,8.0565538e-001f,6.9358288e-001f,5.8151038e-001f,4.6943788e-001f,3.5736538e-001f,2.4529287e-001f,1.3322037e-001f,2.1147870e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8.2272115e-002f,1.9434462e-001f,3.0641712e-001f,4.1848962e-001f,5.3056212e-001f,6.4263462e-001f,7.5470713e-001f,8.6677963e-001f,9.7885213e-001f,9.1446604e-001f,8.0903800e-001f,7.0360996e-001f,5.9818193e-001f,4.9275389e-001f,3.8732585e-001f,2.8189782e-001f,1.7646978e-001f,7.1041745e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8.5533964e-002f,1.9096200e-001f,2.9639004e-001f,4.0181807e-001f,5.0724611e-001f,6.1267415e-001f,7.1810218e-001f,8.2353022e-001f,9.2895826e-001f,9.6765238e-001f,8.6847487e-001f,7.6929737e-001f,6.7011987e-001f,5.7094236e-001f,4.7176486e-001f,3.7258736e-001f,2.7340986e-001f,1.7423235e-001f,7.5054850e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.2347625e-002f,1.3152513e-001f,2.3070263e-001f,3.2988013e-001f,4.2905764e-001f,5.2823514e-001f,6.2741264e-001f,7.2659014e-001f,8.2576765e-001f,9.2494515e-001f,9.7730751e-001f,8.8400997e-001f,7.9071242e-001f,6.9741487e-001f,6.0411733e-001f,5.1081978e-001f,4.1752224e-001f,3.2422469e-001f,2.3092714e-001f,1.3762960e-001f,4.4332053e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.2692488e-002f,1.1599003e-001f,2.0928758e-001f,3.0258513e-001f,3.9588267e-001f,4.8918022e-001f,5.8247776e-001f,6.7577531e-001f,7.6907286e-001f,8.6237040e-001f,9.5566795e-001f,9.5393753e-001f,8.6617134e-001f,7.7840514e-001f,6.9063895e-001f,6.0287275e-001f,5.1510656e-001f,4.2734036e-001f,3.3957417e-001f,2.5180797e-001f,1.6404178e-001f,7.6275582e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4.6062466e-002f,1.3382866e-001f,2.2159486e-001f,3.0936105e-001f,3.9712725e-001f,4.8489344e-001f,5.7265964e-001f,6.6042583e-001f,7.4819203e-001f,8.3595822e-001f,9.2372442e-001f,9.8919063e-001f,9.0662785e-001f,8.2406507e-001f,7.4150229e-001f,6.5893950e-001f,5.7637672e-001f,4.9381394e-001f,4.1125115e-001f,3.2868837e-001f,2.4612559e-001f,1.6356281e-001f,8.1000023e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.0809367e-002f,9.3372149e-002f,1.7593493e-001f,2.5849771e-001f,3.4106050e-001f,4.2362328e-001f,5.0618606e-001f,5.8874885e-001f,6.7131163e-001f,7.5387441e-001f,8.3643719e-001f,9.1899998e-001f,9.9852989e-001f,9.2086203e-001f,8.4319416e-001f,7.6552629e-001f,6.8785843e-001f,6.1019056e-001f,5.3252269e-001f,4.5485483e-001f,3.7718696e-001f,2.9951910e-001f,2.2185123e-001f,1.4418336e-001f,6.6515498e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.4701082e-003f,7.9137974e-002f,1.5680584e-001f,2.3447371e-001f,3.1214157e-001f,3.8980944e-001f,4.6747731e-001f,5.4514517e-001f,6.2281304e-001f,7.0048090e-001f,7.7814877e-001f,8.5581664e-001f,9.3348450e-001f,9.8950882e-001f,9.1644567e-001f,8.4338251e-001f,7.7031936e-001f,6.9725620e-001f,6.2419305e-001f,5.5112989e-001f,4.7806674e-001f,4.0500358e-001f,3.3194043e-001f,2.5887727e-001f,1.8581411e-001f,1.1275096e-001f,3.9687803e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.0491175e-002f,8.3554331e-002f,1.5661749e-001f,2.2968064e-001f,3.0274380e-001f,3.7580695e-001f,4.4887011e-001f,5.2193326e-001f,5.9499642e-001f,6.6805957e-001f,7.4112273e-001f,8.1418589e-001f,8.8724904e-001f,9.6031220e-001f,9.6860338e-001f,8.9987193e-001f,8.3114049e-001f,7.6240904e-001f,6.9367760e-001f,6.2494615e-001f,5.5621471e-001f,4.8748326e-001f,4.1875182e-001f,3.5002037e-001f,2.8128893e-001f,2.1255748e-001f,1.4382604e-001f,7.5094592e-002f,6.3631466e-003f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3.1396621e-002f,1.0012807e-001f,1.6885951e-001f,2.3759096e-001f,3.0632240e-001f,3.7505385e-001f,4.4378529e-001f,5.1251674e-001f,5.8124818e-001f,6.4997963e-001f,7.1871107e-001f,7.8744252e-001f,8.5617396e-001f,9.2490541e-001f,9.9363685e-001f,9.4132934e-001f,8.7667279e-001f,8.1201624e-001f,7.4735969e-001f,6.8270314e-001f,6.1804659e-001f,5.5339004e-001f,4.8873349e-001f,4.2407694e-001f,3.5942039e-001f,2.9476384e-001f,2.3010729e-001f,1.6545074e-001f,1.0079419e-001f,3.6137645e-002f,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.8670657e-002f,1.2332721e-001f,1.8798376e-001f,2.5264031e-001f,3.1729686e-001f,3.8195341e-001f,4.4660996e-001f,5.1126651e-001f,5.7592306e-001f,6.4057961e-001f,7.0523616e-001f,7.6989271e-001f,8.3454926e-001f,8.9920581e-001f,9.6386236e-001f,9.7317190e-001f,9.1234866e-001f,8.5152541e-001f,7.9070217e-001f,7.2987893e-001f,6.6905568e-001f,6.0823244e-001f,5.4740919e-001f,4.8658595e-001f,4.2576271e-001f,3.6493946e-001f,3.0411622e-001f,2.4329298e-001f,1.8246973e-001f,1.2164649e-001f,6.0823244e-002f,0
};
//static arm_matrix_instance_f32 MelFilt = {MEL_BANKS, FFT_LEN/2, MelBanks};

static arm_matrix_instance_f32 					MagFFTMtx, MelWinMtx, MelFilt;
static arm_fir_instance_f32 						FirInst;	
static arm_rfft_fast_instance_f32 			RFFTinst, DCTinst_rfft;
static ale_dct2_instance_f32						DCTinst;

//---------------------------------------
//				CALIBRATION VARIABLES
//---------------------------------------

static float32_t THD_E;
static uint32_t  THD_min_FMX,THD_max_FMX;
static float32_t THD_SF;
//static float32_t THD_ZC;

//---------------------------------------
//							VAD VARIABLES
//---------------------------------------
uint8_t age_thd, timeout_thd;
uint32_t age, timeout;
bool proc_frame;


//
//--------	PROCESSING FUNCTIONS --------
//
void featureExtraction (void const *pvParameters)
{
	// Task variables
	Feature_Extraction_args *args;
	osEvent event;
	float32_t *aux;
	VAD_var vad_vars;
	bool end_proc = false;	
	bool first_time = true;
	uint32_t frame_num = 0;
	bool keep_reading;
	
	// Degug variables
	Proc_var *debug_vars = NULL;
	Proc_files *debug_files = NULL;

	// Buffers variables
	ringBuf flt_buff = {NULL}, mfcc_buff = {NULL}, delta_buff = {NULL};
	uint8_t proc_audio_client, proc_flt_client, proc_mfcc_client, proc_delta_client;
	uint8_t packg_mfcc_client, packg_delta_client;
	
	// Get arguments
	args = (Feature_Extraction_args*) pvParameters;
	
	// Create Process Task State MessageQ
	osMessageQDef(proc_msg,5,uint32_t);
	proc_msg = osMessageCreate(osMessageQ(proc_msg),NULL);	
	args->proc_msg_id = proc_msg;
	
	// Init processing
	initProcessing (args->proc_conf);

	// Allocate space for aux variable
	if ( (aux = malloc(args->proc_conf->frame_len * sizeof(float32_t) )) == NULL)
		Error_Handler("Error on malloc aux in audio processing");
	
	// Check if VAD is activated
	if (args->vad_conf->vad)
	{
		age_thd = args->vad_conf->age_thd - 1;																		// En realidad empieza a contar de "0" por eso hay que restarle 1
		timeout_thd = args->vad_conf->timeout_thd + args->proc_conf->theta*2;			// Tengo que sumartle THETA*2 porque es lo que necesito para obtener los doble delta del último frame
		
		// Inicialización
		age = 0;
		timeout = timeout_thd;
		proc_frame = false;
	}
	else
	{
		age_thd = 0;
		timeout_thd = 0;
	}
	
	// Init Ring Buffers
	ringBuf_init ( &flt_buff, 							 args->proc_conf->frame_len					* 2																			* sizeof(float32_t), false);
	ringBuf_init ( &mfcc_buff, 					(1 + args->proc_conf->lifter_length)		* (args->proc_conf->theta*2+1+age_thd)	* sizeof(float32_t), true);
	ringBuf_init ( &delta_buff, 				(1 + args->proc_conf->lifter_length)		* (args->proc_conf->theta*2+1)					* sizeof(float32_t), true);
	ringBuf_init ( args->features_buff, (1 + args->proc_conf->lifter_length)*3	* 20																		* sizeof(float32_t), false);
	
	// Register Proc Clients in Ring Buffers
	ringBuf_registClient ( args->audio_buff,		 args->proc_conf->frame_len			* 1 														* sizeof(uint16_t),				 args->proc_conf->frame_len				* sizeof(uint16_t),	proc_msg, PROC_BUFF_READY,	&proc_audio_client);
	ringBuf_registClient ( &flt_buff,						 args->proc_conf->frame_len     * 1 														* sizeof(float32_t),			 args->proc_conf->frame_overlap 	* sizeof(float32_t),NULL, 		NULL, 						&proc_flt_client);
	ringBuf_registClient ( &mfcc_buff,	   	(1 + args->proc_conf->lifter_length)* (args->proc_conf->theta*2+1)	* sizeof(float32_t),	(1 + args->proc_conf->lifter_length)	* sizeof(float32_t),NULL, 		NULL,							&proc_mfcc_client);
	ringBuf_registClient ( &delta_buff,		 	(1 + args->proc_conf->lifter_length)* (args->proc_conf->theta*2+1)	* sizeof(float32_t),	(1 + args->proc_conf->lifter_length)	* sizeof(float32_t),NULL, 		NULL,							&proc_delta_client);
	
	// Register Package Client in Ring Buffers
	ringBuf_registClient ( &mfcc_buff,	(1 + args->proc_conf->lifter_length) * sizeof(float32_t),(1 + args->proc_conf->lifter_length) * sizeof(float32_t), 	NULL,	NULL,	&packg_mfcc_client);
	ringBuf_registClient ( &delta_buff,	(1 + args->proc_conf->lifter_length) * sizeof(float32_t),(1 + args->proc_conf->lifter_length) * sizeof(float32_t),	NULL, NULL,	&packg_delta_client);
	
	// Allocate space for debug variables
	if ( args->save_to_files )
	{
		// Allocate space for debug variables
		if ( (debug_vars = malloc(sizeof(*debug_vars) )) == NULL)
			Error_Handler("Error on malloc debug_vars in audio processing");
	
		// Allocate space for debug files
		if ( (debug_files = malloc(sizeof(*debug_files) )) == NULL)
			Error_Handler("Error on malloc debug_files in audio processing");
	
		FRESULT res = f_chdir(args->path);
		
		if (args->vad_conf->vad)
			Open_proc_files ( debug_files, All_Stages);
		else
			Open_proc_files ( debug_files, FST_Stage );
		
		allocateProcVariables	( debug_vars, FST_Stage );
		
		if(res == FR_OK)
			f_chdir("..");
	}
	
	//---------------------------- START TASK ----------------------------
	for(;;)
	{
		event = osMessageGet(proc_msg,osWaitForever);
		if(event.status == osEventMessage)
		{
			switch (event.value.v)
			{
				case PROC_BUFF_READY:
				{								
					break;
				}
				case PROC_FINISH:
				{
					end_proc = true;				
					break;
				}
				case PROC_KILL:
				{					
					// Free debug space
					if ( args->save_to_files )
					{
						if (args->vad_conf->vad)
							Close_proc_files ( debug_files, All_Stages);
						else
							Close_proc_files ( debug_files, FST_Stage);
						free(debug_files);
						freeProcVariables (debug_vars, FST_Stage);
						free(debug_vars);
					}

					// Me desregistro del bufer de audio
					ringBuf_unregistClient(args->audio_buff, proc_audio_client);
					ringBuf_unregistClient(&flt_buff, proc_flt_client);
					ringBuf_unregistClient(&mfcc_buff, proc_mfcc_client);
					ringBuf_unregistClient(&mfcc_buff, packg_mfcc_client);
					ringBuf_unregistClient(&delta_buff, proc_delta_client);
					ringBuf_unregistClient(&delta_buff, packg_delta_client);
					
					// Elimino los buffers
					ringBuf_deinit ( &delta_buff );
					ringBuf_deinit ( &mfcc_buff );
					ringBuf_deinit ( &flt_buff );
											
					// Libero memoria
					free(aux);
					
					// Finicializo el proceso
					finishProcessing();
							
					// Destroy Message Que
					osMessageDelete(&proc_msg);
					args->proc_msg_id = NULL;
					
					// Envío mensaje inidicando que termine
					osMessagePut(args->src_msg_id, args->src_msg_val, osWaitForever);
					
					// Espero a que todos los clinetes terminen de leer el buffer
					while( has_ringBuf_clients ( args->features_buff ) )
						osDelay(1);

					// Elimino el buffer
					ringBuf_deinit(args->features_buff);
					
					// Elimino la tarea
					osThreadTerminate(osThreadGetId());
				}
				default:
					break;
			}
			

			do
			{
				keep_reading = false;
				
				// Leemos del buffer de audio y procesamos la primera parte
				if ( ringBuf_read_const( args->audio_buff, proc_audio_client, (uint8_t*) aux ) == BUFF_OK )
				{
					// Procesamos la primera parte
					firstProcStage ( aux, (uint16_t*) aux, debug_vars);
					
					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, First_Stage);
					
					// Guardamos la info en el buffer
					ringBuf_write  ( &flt_buff, (uint8_t*) aux, proc_conf->frame_len * sizeof(float32_t));
					
					keep_reading = true;
				}

				// Process filt audio while it's posible
				if ( ringBuf_read_const ( &flt_buff, proc_flt_client, (uint8_t*) aux ) == BUFF_OK )
				{
					frame_num++;
					
					// Process Second stage
					secondProcStage	( aux, &vad_vars.energy, aux, debug_vars);
					
					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, Second_Stage);
					
					// Process VAD if necesary
					if(args->vad_conf->vad)
					{
						VAD ( &vad_vars, aux, debug_vars);
						
						// Save info if necesary
						if(args->save_to_files)
							Append_proc_files ( debug_files, debug_vars, VAD_Stage);
					}
					
					// Process Third stage
					thirdProcStage	( aux, aux, debug_vars);

					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, Third_Stage);
						
					ringBuf_write (&mfcc_buff, (uint8_t*) aux, proc_conf->lifter_length * sizeof(float32_t));
					ringBuf_write (&mfcc_buff, (uint8_t*) &vad_vars.energy, sizeof(float32_t));
					
					keep_reading = true;
				}

				
				if(!args->vad_conf->vad || vad_vars.VAD)
				{
					// Explicación: Si no se seleccionó VAD proceso igual, pero si VAD esta activado, lo que hago es permitir que le buffer de los MFCC
					// tenga overrun y que los punteros que hayan tenido overrun se actualicen todo el tiempo con el valor más viejo. De esa forma, si
					// el buffer tiene el tamaño adecuado, cuando VAD diga que hay que procesar proceso también las muestras anteriores de VAD (del AGE)
					// y lo necesario para que se procesen todos los coeficientes delta y doble delta
					
					// Process mfcc while it's posible
					if ( ringBuf_read_const ( &mfcc_buff, proc_mfcc_client, (uint8_t*) aux ) == BUFF_OK )
					{
						deltaCoeff ( aux1, aux, proc_conf->theta, 1+proc_conf->lifter_length);
						ringBuf_write (&delta_buff, (uint8_t*) aux1, (1+proc_conf->lifter_length) * sizeof(float32_t));
						keep_reading = true;
					}

					// Process delta_mfcc while it's posible
					if ( ringBuf_read_const ( &delta_buff, proc_delta_client, (uint8_t*) aux1 ) == BUFF_OK )
					{
						// Obtengo los coeficientes doble delta
						deltaCoeff ( &aux[ (1+proc_conf->lifter_length) * 2 ], aux1, proc_conf->theta, 1+proc_conf->lifter_length);
						
						// Si es la primera vez que puedo leer los coeficientes doble delta shifteo los buffers delta y mfcc
						if(first_time)
						{
							ringBuf_shift_Client ( &mfcc_buff, 	packg_mfcc_client, (1+proc_conf->lifter_length) * age_thd									* sizeof(float32_t) );
							ringBuf_shift_Client ( &delta_buff, packg_delta_client,(1+proc_conf->lifter_length) * args->proc_conf->theta 	* sizeof(float32_t) );
							first_time = false;
						}

						// Ahora leo esos buffers
						ringBuf_read_const ( &delta_buff, packg_delta_client, (uint8_t*) &aux[ (1+proc_conf->lifter_length) * 1] );
						ringBuf_read_const ( &mfcc_buff, 	packg_mfcc_client, 	(uint8_t*) &aux[ (1+proc_conf->lifter_length) * 0] );
						
						// Grabo en un archivo
						ringBuf_write (args->features_buff, (uint8_t*) aux, (1+proc_conf->lifter_length) * 3 * sizeof(float32_t));
						
						keep_reading = true;
					}
				}
				else
				{
					// Como termine de procesar reseteo este buffer y hago como que vuelvo a empezar
					if(!is_ringBuf_empty(&delta_buff))
						ringBuf_flush(&delta_buff);
					
					first_time = true;
				}
			}while (keep_reading);
			
			// Finish task
			if(end_proc)
				osMessagePut(proc_msg,PROC_KILL,0);
		}
	}
}

void calibration (void const *pvParameters)
{
	// Task variables
	Calib_args *args;
	osEvent event;
	float32_t *aux;
	VAD_var vad_vars;
	uint32_t frame_num = 0;
	float32_t *SilEnergy  = NULL;
	uint32_t  *SilFmax    = NULL;
	float32_t *SilSpFlat  = NULL;
	bool keep_reading;
	
	// Degug variables
	Proc_var *debug_vars = NULL;
	Proc_files *debug_files = NULL;

	// Buffers variables
	ringBuf flt_buff = {NULL};
	uint8_t calib_audio_client, calib_flt_client;
	
	// Get arguments
	args = (Calib_args*) pvParameters;
	
	// Create Process Task State MessageQ
	osMessageQDef(calib_msg,5,uint32_t);
	calib_msg = osMessageCreate(osMessageQ(calib_msg),NULL);	
	args->calib_msg_id = calib_msg;
	
	// Initialized basic configuration
	initBasics (args->proc_conf);
	
	// Calculo la longitud de la calibraci?n seg?n el tiempo seteado
	uint32_t aprox_calib_len		= (uint32_t)	args->calib_conf->calib_time * args->audio_freq / proc_conf->frame_overlap + 5;

	// Allocate space for variables
	SilEnergy = malloc(aprox_calib_len * sizeof(*SilEnergy));
	SilFmax 	= malloc(aprox_calib_len * sizeof(*SilFmax));
	SilSpFlat = malloc(aprox_calib_len * sizeof(*SilSpFlat));
	if(SilEnergy == NULL || SilFmax == NULL || SilSpFlat == NULL )
		Error_Handler("Cannot allocate Sil variables in AudioCalib");
	
	// Allocate space for aux variable
	if ( (aux = malloc(args->proc_conf->frame_len * sizeof(float32_t) )) == NULL)
		Error_Handler("Error on malloc aux in audio processing");
		
	// Init Ring Buffers
	ringBuf_init ( &flt_buff, args->proc_conf->frame_len * 2 * sizeof(float32_t), false);
	
	// Register Proc Clients in Ring Buffers
	ringBuf_registClient ( args->audio_buff,	args->proc_conf->frame_len * sizeof(uint16_t),	args->proc_conf->frame_len * sizeof(uint16_t),	calib_msg, CALIB_BUFF_READY,	&calib_audio_client);
	ringBuf_registClient ( &flt_buff,					args->proc_conf->frame_len * sizeof(float32_t),	args->proc_conf->frame_overlap * sizeof(float32_t), NULL, 		NULL, 					&calib_flt_client);
	
	// Allocate space for debug variables
	if ( args->save_to_files )
	{
		// Allocate space for debug variables
		if ( (debug_vars = malloc(sizeof(*debug_vars) )) == NULL)
			Error_Handler("Error on malloc debug_vars in audio processing");
	
		// Allocate space for debug files
		if ( (debug_files = malloc(sizeof(*debug_files) )) == NULL)
			Error_Handler("Error on malloc debug_files in audio processing");
		
		FRESULT res = f_chdir(args->path);
		
		Open_proc_files ( debug_files, FSV_Stage);
		allocateProcVariables	(debug_vars, FS_Stage );
		
		if(res == FR_OK)
			f_chdir("..");
	}
	
	//---------------------------- START TASK ----------------------------
	for(;;)
	{
		event = osMessageGet(calib_msg,osWaitForever);
		if(event.status == osEventMessage)
		{
			switch (event.value.v)
			{
				case CALIB_BUFF_READY:
				{
					break;
				}
				case CALIB_FINISH:
				{
					float32_t SilEnergyMean, SilEnergyDev;
					uint32_t  SilFmaxMean, 	SilFmaxDev;
					float32_t SilSpFlatMean,	SilSpFlatDev;
//					float32_t SilZeroCrossMean, SilZeroCrossDev;
						
					// Calculate Mean of Features
					arm_mean_f32 (SilEnergy, frame_num, &SilEnergyMean);
					arm_mean_q31 ((q31_t*)SilFmax, frame_num,(q31_t*) &SilFmaxMean);
					arm_mean_f32 (SilSpFlat, frame_num, &SilSpFlatMean);

					// Calculate Deviation of Features
					arm_std_f32 (SilEnergy, frame_num, &SilEnergyDev);
					arm_std_q31 ((q31_t*)SilFmax, frame_num,(q31_t*) &SilFmaxDev);
					arm_std_f32 (SilSpFlat, frame_num, &SilSpFlatDev);
					
					// Set Thresholds
					THD_E   = SilEnergyMean + args->calib_conf->thd_scl_eng * SilEnergyDev;
					THD_SF  = SilSpFlatMean + args->calib_conf->thd_scl_sf * SilSpFlatDev;
//					THD_FMX = SilFmaxMean > args->calib_conf->thd_min_fmax ? SilFmaxMean : args->calib_conf->thd_min_fmax;
					THD_min_FMX = args->calib_conf->thd_min_fmax ;
					THD_max_FMX = args->calib_conf->thd_max_fmax ;
					

					if(args->save_calib_vars)
					{
						FIL CalibFile;
						uint32_t byteswritten;     							/* File write/read counts */	
						
						f_chdir(args->path);
						
						// Guardo la Energía
						if(f_open(&CalibFile, "CLB_ENR.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilEnergyMean,sizeof(SilEnergyMean),(void*)&byteswritten) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilEnergyDev,	sizeof(SilEnergyDev), (void*)&byteswritten) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &THD_E, 				sizeof(THD_E), 				(void*)&byteswritten) != FR_OK) Error_Handler("");
						f_close(&CalibFile);
							
						// Guardo la Frecuencia Máxima
						if(f_open(&CalibFile, "CLB_FMX.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilFmaxMean,sizeof(SilFmaxMean),(void*)&byteswritten) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilFmaxDev, sizeof(SilFmaxDev),	(void*)&byteswritten) != FR_OK) Error_Handler("");
//						if(f_write(&CalibFile, &THD_min_FMX,sizeof(THD_min_FMX),(void*)&byteswritten) != FR_OK) Error_Handler("");
						f_close(&CalibFile);
						
								// Guardo el Spectral Flatness
						if(f_open(&CalibFile, "CLB_SF.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilSpFlatMean,sizeof(SilSpFlatMean),(void*)&byteswritten) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &SilSpFlatDev,	sizeof(SilSpFlatDev),	(void*)&byteswritten) != FR_OK) Error_Handler("");
						if(f_write(&CalibFile, &THD_SF, 			sizeof(THD_SF),				(void*)&byteswritten) != FR_OK) Error_Handler("");
						f_close(&CalibFile);
						
						f_chdir("..");
					}
					
					osMessageReset(calib_msg);
					osMessagePut(calib_msg,CALIB_KILL,0);
					
					break;
				}
				case CALIB_KILL:
				{					
					// Free debug space
					if ( args->save_to_files )
					{
						Close_proc_files ( debug_files, FSV_Stage);
						free(debug_files);
						freeProcVariables (debug_vars, FS_Stage );
						free(debug_vars);
					}

					// Me desregistro de los buffers
					ringBuf_unregistClient(&flt_buff, calib_flt_client);
					ringBuf_unregistClient(args->audio_buff, calib_audio_client);

					// Elimino los buffers
					ringBuf_deinit ( &flt_buff );
											
					// Free memory
					free(SilEnergy);
					free(SilFmax);
					free(SilSpFlat);
					free(aux);
					
					// Finalizo el procesamiento
					finishBasics();
					
					// Destroy Message Queue
					osMessageDelete(&calib_msg);
					args->calib_msg_id = NULL;
					
					// Envío mensaje inidicando que terminé
					osMessagePut(args->src_msg_id, args->src_msg_val, osWaitForever);
					
					// Elimino la tarea
					osThreadTerminate(osThreadGetId());
				}
				default:
					break;
			}
			
			do
			{
				keep_reading = false;
				
				// Leemos del buffer de audio y procesamos la primera parte
				if ( ringBuf_read_const( args->audio_buff, calib_audio_client, (uint8_t*) aux ) == BUFF_OK)
				{
					// Procesamos la primera parte
					firstProcStage ( aux, (uint16_t*) aux, debug_vars);
					
					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, First_Stage);
					
					// Guardamos la info en el buffer
					ringBuf_write  ( &flt_buff, (uint8_t*) aux, proc_conf->frame_len * sizeof(float32_t));
					keep_reading = true;
				}
				
				// Process filt audio while it's posible
				if (ringBuf_read_const ( &flt_buff, calib_flt_client, (uint8_t*) aux ) == BUFF_OK)
				{
					// Process Second stage
					secondProcStage	( aux, &vad_vars.energy, aux, debug_vars);
					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, Second_Stage );
					
					// Process VAD
					VAD ( &vad_vars, aux, debug_vars);
					// Save info if necesary
					if(args->save_to_files)
						Append_proc_files ( debug_files, debug_vars, VAD_Stage);
					
					// Save variables
					SilEnergy[frame_num] = vad_vars.energy;
					SilFmax[frame_num] = vad_vars.fmax;
					SilSpFlat[frame_num] = vad_vars.sp;
					
					keep_reading = true;
					frame_num++;
				}
				
			}while(keep_reading);
			
		}
	}
}

//
//-----	INIT PROCESSING FUNCTIONS	-------
//
void initProcessing (Proc_conf *proc_config)
{	
	 initBasics (proc_config);
	
	// Instance DCT
	if(dct2_init_f32(&DCTinst, &DCTinst_rfft, proc_conf->dct_len, proc_conf->dct_len/2, sqrt(2.0f/proc_conf->dct_len)) == ARM_MATH_ARGUMENT_ERROR)
		Error_Handler("Error on dct2 instance in audio processing");

	// Creo el Lifter (filtro de Cepstrum)
	if( (CepWeight = malloc(proc_conf->lifter_length * sizeof(*CepWeight))) == NULL)
		Error_Handler("Error on malloc CepWeight in audio processing");
	Lifter_float (CepWeight,proc_conf->lifter_length);

}
void finishProcessing	(void)
{
	// Libero memoria
	free(CepWeight);								CepWeight = NULL;
	finishBasics();
}
void initBasics (Proc_conf *proc_config)
{	
	// Copio la configuración de procesamiento
	proc_conf = proc_config;
	
	// Alloco memoria para aux1 y aux2
	//TODO: EN REALIDAD TENGO QUE ALOCAR LA MEMORIA MAXIMA ENTRE (FRAME_LEN,FFT_LEN, etc)
	if( (aux1 = malloc( max(proc_conf->frame_len,proc_conf->fft_len) * sizeof(*aux1) ) ) == NULL )
		Error_Handler("Error on malloc aux1 in audio processing");
	if( (aux2 = malloc( max(proc_conf->frame_len,proc_conf->fft_len) * sizeof(*aux2) ) ) == NULL )
		Error_Handler("Error on malloc aux2 in audio processing");
	
	// Armo el filtro de Preénfasis
	// Los coeficientes tienen que estar almacenados en tiempo invertido (leer documentación)
	if( (Pre_enfasis_Coeef = malloc( proc_conf->numtaps * sizeof(*Pre_enfasis_Coeef) ) ) == NULL )
		Error_Handler("Error on malloc pre_enfasis_coeef in audio processing");
	Pre_enfasis_Coeef[0] = -proc_conf->alpha;
	Pre_enfasis_Coeef[1]= 1;
	
	// Alloco memoria para el state del filtro de Preénfasis
	if( (pState = malloc( (proc_conf->numtaps + proc_conf->frame_len - 1) * sizeof(*pState) ) ) == NULL )
		Error_Handler("Error on malloc pstate in audio processing");
	arm_fir_init_f32 (&FirInst, proc_conf->numtaps, Pre_enfasis_Coeef, pState, proc_conf->frame_len);
	
	// Creo la ventana de Hamming
	if( (HamWin = malloc(proc_conf->frame_len* sizeof(*HamWin))) == NULL)
		Error_Handler("Error on malloc HamWin in audio processing");
	Hamming_float(HamWin,proc_conf->frame_len);
	
	// Instance FFT
	if(arm_rfft_fast_init_f32 (&RFFTinst, proc_conf->fft_len) == ARM_MATH_ARGUMENT_ERROR)
		Error_Handler("Error on RFFT instance in audio processing");
	
	// Creo la matriz de Filtros Mel
	//TODO Generar programáticamente los MelBanks y eliminarlo de arriba (y siempre utilizar los valores en proc_conf)
	arm_mat_init_f32 (&MelFilt, proc_conf->mel_banks, proc_conf->fft_len/2, MelBanks);
}
void finishBasics	(void)
{
	// Libero memoria
	free(HamWin);									HamWin = NULL;
	free(pState);									pState = NULL;
	free(Pre_enfasis_Coeef);			Pre_enfasis_Coeef = NULL;
	free(aux2);										aux2 = NULL;
	free(aux1);										aux1 = NULL;
}
void Hamming_float (float32_t *Hamming, uint32_t length)
{
	uint32_t i;
	const float32_t a=0.54 , b=0.46;
	
	for(i=0; i < length; i++) {
		Hamming[i] = a - b * arm_cos_f32 ((float32_t)2*PI*i/length);
	}
}
void Lifter_float (float32_t *Lifter, uint32_t length)
{
	
	float32_t theta;
	uint32_t n;
	
	for(n=0; n<length; n++) {
		theta = PI*n/(length-1);
		Lifter[n] = 1 + arm_sin_f32(theta) * length/2;
	}
}
//
//-----	PROCESSING FUNCTIONS	-------
//
void firstProcStage 	(float32_t *filt_signal, uint16_t *audio, Proc_var *saving_var)
{
	/* Convierto a Float y escalo */
	arm_q15_to_float((q15_t*)audio, aux1, proc_conf->frame_len);

	/* Se aplica un filtro de Pre-énfais al segmento de señal obtenida */	
	arm_fir_f32 (&FirInst, aux1, filt_signal, proc_conf->frame_len);

	// Copio las variables de ser necesario
	if(saving_var != NULL)
	{
		arm_copy_f32 (aux1, saving_var->speech, proc_conf->frame_len);
		arm_copy_f32 (filt_signal, saving_var->FltSig, proc_conf->frame_len);
	}
}

void secondProcStage	(float32_t *MagFFT, float32_t *Energy, float32_t *frame_block, Proc_var *saving_var)
{
	
	/* Se le aplica la ventana de Hamming al segmento obtenido */
	arm_mult_f32 (frame_block, HamWin, aux1, proc_conf->frame_len);
	
	// Copio las variables de ser necesario
	if(saving_var != NULL)
	{
		arm_copy_f32 (frame_block, saving_var->Frame, proc_conf->frame_len);
		arm_copy_f32 (aux1, saving_var->WinSig, proc_conf->frame_len);
	}
		
	/* Calculo la energía */
	arm_power_f32 (aux1, proc_conf->frame_len, Energy);
	*Energy /= proc_conf->frame_len;
	
	/* Se calcula la STFT */
	arm_rfft_fast_f32(&RFFTinst,aux1,aux2,0);
	
	/* Calculo el módulo de la FFT */
	arm_cmplx_mag_squared_f32  (aux2, MagFFT, proc_conf->fft_len/2);

	// Copio las variables de ser necesario
	if(saving_var != NULL)
	{
		arm_copy_f32 (aux2, saving_var->STFTWin, proc_conf->frame_len);
		arm_copy_f32 (MagFFT, saving_var->MagFFT,  proc_conf->fft_len/2);
	}
}
void thirdProcStage 	(float32_t *MFCC, float32_t *MagFFT, Proc_var *saving_var)
{
	
	/* Se pasa el espectro por los filtros del banco de Mel y se obtienen los coeficientes */
	arm_mat_init_f32 (&MagFFTMtx, proc_conf->fft_len/2, 1, MagFFT);																			// Se convierte la STFT a una Matriz de filas=fftLen y columnas=1
	arm_mat_init_f32 (&MelWinMtx, proc_conf->mel_banks, 1, aux1);																				// Se crea una matriz para almacenar el resultado
	if(arm_mat_mult_f32(&MelFilt, &MagFFTMtx, &MelWinMtx) == ARM_MATH_SIZE_MISMATCH)
		Error_Handler("Error on thirdProcStage");
	// MelFilt[MEL_BANKS,proc_conf->fft_len] * MagFFTMtx[proc_conf->fft_len,1] = MelWinMtx [MEL_BANKS,1]
	
	/* Se obtienen los valores logaritmicos de los coeficientes */
	arm_fill_f32 	(0, aux2, proc_conf->dct_len);
	for (uint32_t i=0; i<proc_conf->mel_banks; i++)
		aux2[i] = log10f(aux1[i]);
	
	// Copio las variables
	if(saving_var != NULL)
	{
		arm_copy_f32 (aux1, saving_var->MelWin, proc_conf->mel_banks);
		arm_copy_f32 (aux2, saving_var->LogWin, proc_conf->dct_len);
	}
	
	/* Se Anti-transforma aplicando la DCT-II */
	ale_dct2_f32(&DCTinst, aux1, aux2);
	
	/* Se pasa la señal por un filtro en el campo Cepstral */
	arm_mult_f32 (aux2, CepWeight, MFCC, proc_conf->lifter_length);

	// Copio las variables
	if(saving_var != NULL)
	{
		arm_copy_f32 (aux2, saving_var->CepWin, proc_conf->dct_len/2);
		arm_copy_f32 (MFCC, saving_var->MFCC, 	proc_conf->lifter_length);
	}
	
}
void VAD (VAD_var *vad, float32_t *MagFFT, Proc_var *saving_var)
{
	float32_t AM,GM;
	
	/* Obtengo la Fmax */
	// No me interesa el valor máximo, sino en que lugar se encuentra
	// Empiezo a contar de la muestra 1 porque la 0 es la continua y no esta bien tenerla en cuenta
	// Por eso luego le debo sumar uno para que se realize el desplazamiento por la continua
	arm_max_f32 (&MagFFT[1], proc_conf->fft_len/2-1, aux1, &vad->fmax);
	vad->fmax++;
	
	/* Calculo el Spectral Flatness */
	arm_mean_f32 (MagFFT, proc_conf->fft_len/2, &AM);	// Arithmetic Mean
	sumlog(MagFFT, &GM, proc_conf->fft_len/2);
	GM = expf(GM/(proc_conf->fft_len/2));							// Geometric Mean
	vad->sp = fabsf(10*log10f(GM/AM));
	
	// VAD algorithm
	if ( (vad->energy > THD_E && THD_min_FMX < vad->fmax && vad->fmax < THD_max_FMX) || vad->sp > THD_SF)
	{
		age++;
		if (age > age_thd)
		{
			timeout = timeout_thd;
			proc_frame = true;
		}
	}
	else
	{
		if (proc_frame)
		{
			if (timeout == 0)
			{
				proc_frame = false;
				age = 0;
			}
			timeout--;
		}
	}
	
	vad->VAD = proc_frame;
	
	// Copio las variables
	if(saving_var != NULL)
		saving_var->vad_vars = *vad;
}
void deltaCoeff				(float32_t *output, float32_t *input, uint8_t theta, uint8_t num_params)
{
	int step = num_params;
	
	// Inicializo el buffer en 0
	arm_fill_f32(0,output,num_params);
	
	// Calculo el numerador
	for(int i = num_params; i  ; i--)
		for(int j = theta; j; j--)
			output[i-1] += j * (input[(theta+j)*step + (i-1)] - input[(theta-j)*step + (i-1)]);
	
	// Calculo el denominador
	float32_t divisor =0;	
	for(int j = theta; j; j--)
		divisor += j * j;
	divisor *= 2;
	
	// Divido por el denominador
	arm_scale_f32 (output, 1/divisor, output, num_params);
}
//
//----- MISCELLANEOUS FUNCTIONS -----
//
void allocateProcVariables (Proc_var *var, Proc_stages stage)
{
	if(stage & First_Stage)
	{
		var->speech		= malloc(proc_conf->frame_len * sizeof(*(var->speech)));		// Señal de audio escalada
		var->FltSig		= malloc(proc_conf->frame_len * sizeof(*(var->FltSig)));		// Señal de audio pasada por el Filtro de Pre-Enfasis
		
		if(var->speech == NULL || var->FltSig == NULL )
			Error_Handler("Error on malloc of proc variables");
	}
	
	if(stage & Second_Stage)
	{
		var->Frame		= malloc(proc_conf->frame_len * sizeof(*(var->Frame)));		// Frame de señal
		var->WinSig		= malloc(proc_conf->frame_len * sizeof(*(var->WinSig)));		// Señal de filtrada multiplicada por la ventana de Hamming
		var->STFTWin	= malloc(proc_conf->fft_len   * sizeof(*(var->STFTWin)));	// Transformada de Fourier en Tiempo Corto
		var->MagFFT		= malloc(proc_conf->fft_len/2 * sizeof(*(var->MagFFT)));		// Módulo del espectro
		
		if(var->WinSig == NULL || var->STFTWin == NULL || var->MagFFT == NULL)
			Error_Handler("Error on malloc of proc variables");
	}
		
	if(stage & Third_Stage)
	{
		var->MelWin		= malloc(proc_conf->mel_banks * sizeof(*(var->MelWin)));		// Espectro pasado por los filtros de Mel
		var->LogWin		= malloc(proc_conf->dct_len  * sizeof(*(var->LogWin)));		// Logaritmo del espectro filtrado
		var->CepWin		= malloc(proc_conf->dct_len/2			* sizeof(*(var->CepWin)));		// Señal cepstral
		var->MFCC			= malloc(proc_conf->lifter_length	* sizeof(*(var->MFCC)));			// Coeficientes MFCC
		
		if(var->MelWin == NULL || var->LogWin == NULL || var->CepWin == NULL || var->MFCC == NULL)
			Error_Handler("Error on malloc of proc variables");
	}

}
void freeProcVariables (Proc_var *var, Proc_stages stage)
{
	if(stage & First_Stage)
	{
		free(var->speech);			var->speech = NULL;
		free(var->FltSig);			var->FltSig = NULL;
	}
	
	if(stage & Second_Stage)
	{
		free(var->Frame);				var->Frame = NULL;
		free(var->WinSig);			var->WinSig = NULL;
		free(var->STFTWin);			var->STFTWin = NULL;
		free(var->MagFFT);			var->MagFFT = NULL;
	}
		
	if(stage & Third_Stage)
	{
		free(var->MelWin);			var->MelWin = NULL;
		free(var->LogWin);			var->LogWin = NULL;
		free(var->CepWin);			var->CepWin = NULL;
		free(var->MFCC);				var->MFCC = NULL;
	}
}
uint8_t Open_proc_files (Proc_files *files, Proc_stages stage)
{
	UINT byteswritten;
					
	if(stage & First_Stage)
	{
		//Abro los archivos
		if(f_open(&files->SpeechFile, "Speech.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on Speech open");
		if(f_open(&files->FltSigFile, "FltSig.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on FltSig open");
	}
	
	if(stage & Second_Stage)
	{
		// Escribo un archivo con los coeficientes de la ventana de Hamming			
		if(f_open(&files->HamWinFile, "HamWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)Error_Handler("Error on HamWinFile open");
		if(f_write(&files->HamWinFile, HamWin, proc_conf->frame_len * sizeof(*HamWin), &byteswritten) != FR_OK)	Error_Handler("Error on HamWinFile write");
		f_close(&files->HamWinFile);
		
		if(f_open(&files->FrameFile, 	"Frames.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on Frames open");
		if(f_open(&files->WinSigFile, "WinSig.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on WinSig open");
		if(f_open(&files->STFTWinFile,"FFTWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on FFTWin open");
		if(f_open(&files->MagFFTFile, "MagFFT.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on MagFFT open");
	}
		
	if(stage & Third_Stage)
	{
		// Escribo un archivo con los coeficientes del Filtro Cepstral
		if(f_open(&files->CepWeiFile, "CepWei.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on CepWeiFile open");
		if(f_write(&files->CepWeiFile, CepWeight, proc_conf->lifter_length * sizeof(*CepWeight), &byteswritten) != FR_OK)	Error_Handler("Error on CepWeiFile write");
		f_close(&files->CepWeiFile);
		
		if(f_open(&files->MelWinFile, "MelWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on MelWin open");
		if(f_open(&files->LogWinFile, "LogWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on LogWin open");
		if(f_open(&files->CepWinFile, "CepWin.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on CepWin open");
		if(f_open(&files->MFCCFile, 	"MFCC.bin", 	FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on MFCC open");
	}

	if(stage & VAD_Stage)
	{
		if(f_open(&files->VADFile,			 "VAD.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on VAD open");
		if(f_open(&files->EnerFile,		"Energy.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on Energy open");
		if(f_open(&files->FrecFile,  "FrecMax.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on FrecMax open");
		if(f_open(&files->SFFile,		"SpecFlat.bin",	FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler("Error on SpecFlat open");
	}

//	if(f_open(&files->nosirve, "nosirve.bin", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)		Error_Handler();

	return 0;
}
uint8_t Append_proc_files (Proc_files *files, const Proc_var *var, Proc_stages stage)
{
	UINT byteswritten;
	
	//Escribo los valores intermedios en un archivo
	
	if (stage & First_Stage)
	{
		if(f_write(&files->SpeechFile,  var->speech, proc_conf->frame_len * sizeof(*var->speech),  &byteswritten) != FR_OK)	Error_Handler("Error on SpeechFile write");
		if(f_write(&files->FltSigFile,  var->FltSig, proc_conf->frame_len * sizeof(*var->FltSig),  &byteswritten) != FR_OK)	Error_Handler("Error on FltSigFile write");
	}
	
	if(stage & Second_Stage)
	{
		if(f_write(&files->FrameFile,  	var->Frame,  proc_conf->frame_len * sizeof(*var->Frame), 	&byteswritten) != FR_OK)	Error_Handler("Error on FrameFile write");
		if(f_write(&files->WinSigFile,  var->WinSig, proc_conf->frame_len * sizeof(*var->WinSig),  &byteswritten) != FR_OK)	Error_Handler("Error on WinSigFile write");
		if(f_write(&files->STFTWinFile, var->STFTWin,proc_conf->fft_len		* sizeof(*var->STFTWin), &byteswritten) != FR_OK)	Error_Handler("Error on STFTWinFile write");
		if(f_write(&files->MagFFTFile,  var->MagFFT, proc_conf->fft_len/2 * sizeof(*var->MagFFT),  &byteswritten) != FR_OK)	Error_Handler("Error on MagFFTFile write");
	}
	
	if(stage & Third_Stage)
	{
		if(f_write(&files->MelWinFile,  var->MelWin,	proc_conf->mel_banks 		* sizeof(*var->MelWin), &byteswritten) != FR_OK)	Error_Handler("Error on MelWinFile write");
		if(f_write(&files->LogWinFile,	var->LogWin,	proc_conf->dct_len   		*	sizeof(*var->LogWin), &byteswritten) != FR_OK)	Error_Handler("Error on LogWinFile write");
		if(f_write(&files->CepWinFile,	var->CepWin,	proc_conf->dct_len/2 		* sizeof(*var->CepWin), &byteswritten) != FR_OK)	Error_Handler("Error on CepWinFile write");
		if(f_write(&files->MFCCFile,  	var->MFCC, 		proc_conf->lifter_length* sizeof(*var->MFCC),		&byteswritten) != FR_OK)	Error_Handler("Error on MFCCFile write");
	}
	
	if(stage & VAD_Stage)
	{
		if(f_write(&files->EnerFile,&var->vad_vars.energy,	sizeof(var->vad_vars.energy),	&byteswritten) != FR_OK)	Error_Handler("Error on EnerFile write");
		if(f_write(&files->FrecFile,&var->vad_vars.fmax,		sizeof(var->vad_vars.fmax),		&byteswritten) != FR_OK)	Error_Handler("Error on FrecFile write");
		if(f_write(&files->SFFile,	&var->vad_vars.sp,			sizeof(var->vad_vars.sp),			&byteswritten) != FR_OK)	Error_Handler("Error on SFFile write");
		if(f_write(&files->VADFile,	&var->vad_vars.VAD,			sizeof(var->vad_vars.VAD),		&byteswritten) != FR_OK)	Error_Handler("Error on VADFile write");
	}
	return 1;
}
uint8_t Close_proc_files (Proc_files *files, Proc_stages stage)
{
	if(stage & First_Stage)
	{
		f_close(&files->SpeechFile);
		f_close(&files->FltSigFile);
	}
	
	if(stage & Second_Stage)
	{
		f_close(&files->FrameFile);
		f_close(&files->WinSigFile);
		f_close(&files->STFTWinFile);
		f_close(&files->MagFFTFile);
	}
	
	if(stage & Third_Stage)
	{
		f_close(&files->MelWinFile);
		f_close(&files->LogWinFile);
		f_close(&files->CepWinFile);
		f_close(&files->MFCCFile);
	}
	
	if(stage & VAD_Stage)
	{
		f_close(&files->EnerFile);
		f_close(&files->FrecFile);
		f_close(&files->SFFile);
		f_close(&files->VADFile);
	}
	
//	f_close(&files->nosirve);
	return 1;
}



////	ale_dct2_instance_f32 			dct2_instance;
////	arm_rfft_fast_instance_f32 	rfft_instance;
////	float32_t pState[64];
////
//// Los valores fueron obtenidos mediante la ecuación x = 50*cos((1:32)*2*pi/40);
////
////	float32_t pInlineBuffer[32]={		49.384417029756889f,		47.552825814757675f,		44.550326209418394f,		40.450849718747371f,
////		35.355339059327378f,		29.389262614623657f,		22.699524986977345f,		15.450849718747373f,		7.821723252011546f,
////		0.000000000000003f,		-7.821723252011529f,		-15.450849718747367f,		-22.699524986977337f,		-29.389262614623650f,
////		-35.355339059327370f,		-40.450849718747364f,		-44.550326209418387f,		-47.552825814757675f,		-49.384417029756882f,
////		-50.000000000000000f,		-49.384417029756889f,		-47.552825814757689f,		-44.550326209418394f,		-40.450849718747371f,
////		-35.355339059327385f,		-29.389262614623661f,		-22.699524986977345f,		-15.450849718747378f,		-7.821723252011552f,
////		-0.000000000000009f,		7.821723252011534f,		15.450849718747362f,
////	};
////	
////	dct2_init_f32(&dct2_instance, &rfft_instance, 32, 16, sqrt(2.0f/32.0f));
////	ale_dct2_f32(&dct2_instance, pState, pInlineBuffer);





//		// Shifteo la ventana FRAME_OVERLAP veces
//		// Para ello, shifteo lo viejo y copio el nuevo frame al final
////		memcpy(&frame_block[proc_conf->zero_padding_left], &frame_block[proc_conf->zero_padding_left + proc_conf->frame_overlap], (proc_conf->frame_net + proc_conf->frame_overlap) * sizeof(*frame_block));
////		memcpy(&frame_block[proc_conf->zero_padding_left + proc_conf->frame_overlap + proc_conf->frame_net], saving_var->FltSig, proc_conf->frame_net * sizeof(*saving_var->FltSig));
//// Shifteo la ventana FRAME_OVERLAP veces
//		// Para ello, shifteo lo viejo y copio el nuevo frame al final
////		memcpy(&frame_block[proc_conf->zero_padding_left], &frame_block[proc_conf->zero_padding_left + proc_conf->frame_overlap], (proc_conf->frame_net + proc_conf->frame_overlap) * sizeof(*frame_block));
////		memcpy(&frame_block[proc_conf->zero_padding_left + proc_conf->frame_overlap + proc_conf->frame_net], aux2, proc_conf->frame_net * sizeof(*aux2));
